package IC.Parser;

import java.util.List;
import java.util.ArrayList;

import java_cup.runtime.*;

import IC.DataTypes;
import IC.AST.*;


parser code  {:
       /** Causes the parser to print every token it reads.
        * This is useful for debugging.
	*/
        public boolean printTokens;
        private Lexer lexer;
       
        public Parser(Lexer lexer) {
       	      super(lexer);
	      this.lexer = lexer;
        }
			
	public int getLine() {
	       return lexer.getLineNumber();
	}
			       
	public void syntax_error(Symbol s) {
	       Token tok = (Token) s;
	       System.out.println("Line " + tok.getLine() + ": Syntax error; unexpected " + tok);
	}
:}

// This is just for debugging
scan with {:
     Token t = lexer.next_token();
     if (printTokens)
     	System.out.println(t.getLine() + ":" + t);
     return t; 
:};

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

// Punctuation marks
terminal LP, RP, LB, RB, LCBR, RCBR, SEMI, DOT, COMMA;
// Keywords
terminal CLASS, EXTENDS, STATIC, VOID, INT, BOOLEAN, STRING, RETURN, IF, ELSE, WHILE, BREAK, CONTINUE, THIS, NEW, LENGTH, TRUE, FALSE, NULL;

// Stuff that have text in them
terminal String ID, CLASS_ID, QUOTE;
terminal Integer INTEGER;

// Assignment operator
terminal ASSIGN;

// Boolean operators
terminal EQUAL, NEQUAL, LT, GT, LTE, GTE;

// Binary operators
terminal PLUS, MINUS, MULTIPLY, DIVIDE, MOD;

// Unary operators
terminal UMINUS, LNEG;

// Conditional operators
terminal LAND, LOR;

non terminal Program program;
non terminal ICClass class;
non terminal List<ICClass> class_list;
non terminal List<ASTNode> fields_or_methods;
non terminal List<ASTNode> field_or_method;
non terminal List<Field> field;
non terminal Method method;
non terminal Type type;
non terminal List<Formal> formals;
non terminal Formal formal;
non terminal List<Statement> statement_list;
non terminal Statement statement;
non terminal List<String> id_list;
non terminal Expression expression;
non terminal Location location;
non terminal binop, unop;
non terminal literal;
non terminal Call call;
non terminal StaticCall static_call;
non terminal VirtualCall virtual_call;
non terminal arg_list;

//////////////////////////
// Precedence declarations

precedence left LOR;
precedence left LAND;
precedence left EQUAL, NEQUAL;
precedence left LT, LTE, GT, GTE;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence left LB;
precedence left ELSE;
precedence left DOT;

//////////////
// The grammar

program ::= class_list:cl
	{: System.out.println("Producing Program");
	   RESULT = new Program(cl); :};

// TODO: consider reversing
class_list ::=
	   {:
	     RESULT = new ArrayList<ICClass>();
	   :} |
	   class:c class_list:cl {:
   	     cl.add(c);
	     RESULT = cl;
           :};

class ::=
      CLASS CLASS_ID:cid LCBR fields_or_methods:fom RCBR {:
         List<Field> fields = new ArrayList<Field>();
         List<Method> methods = new ArrayList<Method>();
	 for (ASTNode fieldOrMethod : fom) {
	   if (fieldOrMethod instanceof Field) {
	     fields.add((Field)fieldOrMethod);
	   } else {
	     methods.add((Method)fieldOrMethod);
	   }
	 }
         RESULT = new ICClass(cidleft, cid, fields, methods);
      :} |
      CLASS CLASS_ID:cid EXTENDS CLASS_ID:superid LCBR fields_or_methods:fom RCBR {:
         List<Field> fields = new ArrayList<Field>();
         List<Method> methods = new ArrayList<Method>();
	 for (ASTNode fieldOrMethod : fom) {
	   if (fieldOrMethod instanceof Field) {
	     fields.add((Field)fieldOrMethod);
	   } else {
	     methods.add((Method)fieldOrMethod);
	   }
	 }
         RESULT = new ICClass(cidleft, cid, superid, fields, methods);
      :};

// TODO: consider reversing
fields_or_methods ::=
		  {: RESULT = new ArrayList<ASTNode>(); :} |
		  field_or_method:items fields_or_methods:list {:
		    for (ASTNode item : items) {
  		      list.add(item);
		    }
		  :};

field_or_method ::=
		field:flist {:
		  List<ASTNode> items = new ArrayList<ASTNode>();
		  for (Field f : flist) {
  		    items.add(f);
		  }
		  RESULT = items;
		:} |
		method:m {:
		  List<ASTNode> items = new ArrayList<ASTNode>();
		  items.add(m);
		  RESULT = items;
		  :};

field ::= type:t id_list:names SEMI {:
            List<Field> list = new ArrayList<Field>();
            for (String name : names) {
              list.add(new Field(t, name));
	    }
	    RESULT = list;
	  :};

id_list ::= ID:id {:
	      System.out.println(id);
	      List<String> ids = new ArrayList<String>();
	      ids.add(id);
	      RESULT = ids;
	    :} |
	    id_list:ids COMMA ID:id {:
	      ids.add(id);
	      RESULT = ids;
	    :};

method ::= type:t ID:name LP formals:f RP LCBR statement_list:s RCBR {:
         RESULT = new VirtualMethod(t, name, f, s);
       :} |
       VOID:t ID:name LP formals:f RP LCBR statement_list:s RCBR {:
         Type voidType = new PrimitiveType(tleft, DataTypes.VOID);
         RESULT = new VirtualMethod(voidType, name, f, s);
       :} |
       STATIC type:t ID:name LP formals:f RP LCBR statement_list:s RCBR {:
         RESULT = new StaticMethod(t, name, f, s);
       :} |
       STATIC VOID:t ID:name LP formals:f RP LCBR statement_list:s RCBR {:
         Type voidType = new PrimitiveType(tleft, DataTypes.VOID);
         RESULT = new StaticMethod(voidType, name, f, s);
       :};

formals ::= {:
     	  RESULT = new ArrayList<Formal>();
	:} |
	formal:formal {:
	  List<Formal> formals = new ArrayList<Formal>();
	  formals.add(formal);
	  RESULT = formals;
	:} |
	formals:formals COMMA formal:formal {:
	  formals.add(formal);
	  RESULT = formals;
	:};

formal ::= type:type ID:id {:
         RESULT = new Formal(type, id);
       :};

type ::= INT:t {:
       	 RESULT = new PrimitiveType(tleft, DataTypes.INT);
       :} |
       BOOLEAN:t {:
         RESULT = new PrimitiveType(tleft, DataTypes.BOOLEAN);
       :} |
       STRING:t {:
         RESULT = new PrimitiveType(tleft, DataTypes.STRING);
       :} |
       CLASS_ID:name {:
         RESULT = new UserType(nameleft, name);
       :} |
       type:t LB RB {:
         t.incrementDimension();
         RESULT = t;
       :};

statement_list ::= {:
	         RESULT = new ArrayList<Statement>();
	       :} |
	       statement:statement statement_list:statement_list {:
	         statement_list.add(statement);
		 RESULT = statement_list;
	       :};

statement ::= location:variable ASSIGN expression:expression SEMI {:
	    RESULT = new Assignment(variable, expression);
	  :} |
	  call:call SEMI {:
	    RESULT = new CallStatement(call);
	  :} |
	  RETURN:r SEMI {:
	    RESULT = new Return(rleft);
	  :}
	  | RETURN:r expression:expression SEMI {:
	    RESULT = new Return(rleft, expression);
	  :}
	  | IF LP expression:condition RP statement:operation {:
	    RESULT = new If(condition, operation);
	  :}
	  | IF LP expression:condition RP statement:operation ELSE statement:elseOperation {:
	    RESULT = new If(condition, operation, elseOperation);
	  :}
	  | WHILE LP expression:condition RP statement:operation {:
	    RESULT = new While(condition, operation);
	  :}
	  | BREAK:b SEMI {:
	    RESULT = new Break(bleft);
	  :}
	  | CONTINUE:c SEMI {:
	    RESULT = new Continue(cleft);
	  :}
	  | LCBR:begin statement_list:statements RCBR {:
	    RESULT = new StatementsBlock(beginleft, statements);
	  :}
	  | type:type ID:name SEMI {:
	    RESULT = new LocalVariable(type, name);
	  :}
	  | type:type ID:name ASSIGN expression:initValue SEMI {:
	    RESULT = new LocalVariable(type, name, initValue);
	  :};

expression ::= location:location {: RESULT = location; :}
	   | call:call {: RESULT = call; :}
	   | THIS:t {: RESULT = new This(tleft); :}
	   | NEW CLASS_ID LP RP
	   | NEW type LB expression RB
	   | expression DOT LENGTH
	   | expression binop expression
	   | unop expression
	   | literal
	   | LP expression RP;

call ::= static_call | virtual_call;
static_call ::= CLASS_ID DOT ID LP arg_list RP;
virtual_call ::= ID LP arg_list RP
	     | expression DOT ID LP arg_list RP;
arg_list ::= | expression | expression COMMA arg_list;

location ::= ID | expression DOT ID | expression LB expression RB;

binop ::= PLUS | MINUS | MULTIPLY | DIVIDE | MOD | LAND | LOR
      | LT | LTE | GT | GTE | EQUAL | NEQUAL;

unop ::= MINUS %prec UMINUS | LNEG;

literal ::= INTEGER | QUOTE | TRUE | FALSE | NULL;
_________________________________
Compilation project documentation
Exercise 3
=================================

Summary: In this exercise we implemented semantic analysis for the IC language, 
including symbol table construction.


_______________
CLASS HIERARCHY

The project consists of three packages:

IC: Has the Compiler main class and some basic types that define the IC language.
IC.Parser package: Does lexical and syntactic analysis.
IC.AST pacakge: Holds the data that will be relevant in the future phases of the compilation process.
                NOTE: This package was almost not changed for PA2 (from the version that was supplied
                      in the code skeleton).


package IC:

> Compiler.java - Changed from PA1.
                  It now runs a parser for two files: the Library signature file is 
                  parsed with IC.Parser.LibraryParser and the IC source file is parsed with IC.Parser.Parser.
                  In case -print-ast command line arg is specified, IC.AST.PrettyPrinter is used to print the
                  parsed source file, with the root Program element.
                  The Library signature file is also printed. It is treated as an ICClass.
> BinaryOps.java, DataTypes.java, LiteralTypes.java and UnaryOps.java - Those classes that represent
  aspects of the IC language were not changed for PA2.


package IC.Parser:

> ClassMembersHelper.java - Used to hold the different fields of a class while parsing class members
                            (fields and methods).
> CourtesyErrorReporter.java - Used for error printing during parsing. More details below.
> IC.cup - The grammar and AST building instructions for IC language. Generates Parser.java and sym.java.
> IC.lex - Unchanged from PA1. Generates Lexer.java.
> LexicalError.java - Unchanged from PA1.
> Library.cup - The grammar and AST building instructions for libic.sig file. Generates LibraryParser.java.
> LiteralParser.java - Used for parsing literals (unescaping and unquoting QUOTEs).
> sym.java - Changed from PA1. Now auto-generated by JCUP when generating Parser from IC.cup
> symNameGetter.java - A helper class with some reflection methods to get a symbol's name by value; used
                       in Token.toString().
> SyntaxError.java - Helps with handling and printing errors during the parsing stage.
> Token.java - Unchanged from PA1.


package IC.AST:

Almost didn't change from the proposed AST. The AST classes themselves didn't change at all. The only change we did is in PrettyPrinter, so that it'd print to System.out as it goes, instead of building a giant String (used for debugging).

________________
TESTING STRATEGY

Production rules were added to the grammar while working opposite Quicksort.ic. That is, every time
a rule was added, we checked that we are making progress in parsing Quicksort.ic.

Later, after Quicksort.ic was parsed as a whole, the rest of the IC grammar was introduced to IC.cup.

Then, the file OrderOfThings.ic was created to test for additional issues and corner cases we could've thought of.

Finally the file TestBonus2Case.ic was created for the cases in bonus 2.

_______________
ERROR REPORTING

For each semantic error, we try to show some informative info:

- The line number in which the erroneous token appeared;
- The erroneous token itself;
- The whole line to give context;

_____________________________
DESIGN/IMPLEMENTATION CHOICES (not all of are good in retrospect)

1. We didn't add a reference to the enclosing Symbol Table from each AST Node.
   Instead, while traversing the AST, we keep track of what is the current enclosing
   scope. This has proven to be a bad design choice, that will probably have to be
   changed for the next PA.
   
2. Integer bounds checking is hackish: to allow -2147483648 it checks if the parent is the parent is UMinus.
   It's hard to do any better without constant folding.
   
3. Each step of the semantic checks (almost) is done in its own Visitor.
   PropagatingVisitor was implemented too late. Some of the visitors should've been
   propagating.

4. There's a Scope checker and a Type checker. Sometimes it's hard to tell if
   a certain issue is a 'scope' issue or a 'type' issue. Rule of thumb: if a certain
   semantic check requires only the symbol's kind but not its type, it's in the Scope
   checker.
   
5. Main function validator is implemented in an AST visitor. It should've been checked
   on the symbol table (that was though of only after the symbol table was built). 
_________________________________
Compilation project documentation
Exercise 2
=================================

Summary: In this exercise we implemented syntax analysis for the IC language, including AST construction.


_______________
CLASS HIERARCHY

The project consists of three packages:

IC: Has the Compiler main class and some basic types that define the IC language.
IC.Parser package: Does lexical and syntactic analysis.
IC.AST pacakge: Holds the data that will be relevant in the future phases of the compilation process.
                NOTE: This package was almost not changed for PA2 (from the version that was supplied
                      in the code skeleton).


package IC:

> Compiler.java - Changed from PA1.
                  It now runs a parser for two files: the Library signature file is 
                  parsed with IC.Parser.LibraryParser and the IC source file is parsed with IC.Parser.Parser.
                  In case -print-ast command line arg is specified, IC.AST.PrettyPrinter is used to print the
                  parsed source file, with the root Program element.
                  The Library signature file is also printed. It is treated as an ICClass.
> BinaryOps.java, DataTypes.java, LiteralTypes.java and UnaryOps.java - Those classes that represent
  aspects of the IC language were not changed for PA2.


package IC.Parser:

> ClassMembersHelper.java - Used to hold the different fields of a class while parsing class members
                            (fields and methods).
> CourtesyErrorReporter.java - Used for error printing during parsing. More details below.
> IC.cup - The grammar and AST building instructions for IC language. Generates Parser.java and sym.java.
> IC.lex - Unchanged from PA1. Generates Lexer.java.
> LexicalError.java - Unchanged from PA1.
> Library.cup - The grammar and AST building instructions for libic.sig file. Generates LibraryParser.java.
> LiteralParser.java - Used for parsing literals (unescaping and unquoting QUOTEs).
> sym.java - Changed from PA1. Now auto-generated by JCUP when generating Parser from IC.cup
> symNameGetter.java - A helper class with some reflection methods to get a symbol's name by value; used
                       in Token.toString().
> SyntaxError.java - Helps with handling and printing errors during the parsing stage.
> Token.java - Unchanged from PA1.


package IC.AST:

Almost didn't change from the proposed AST. The AST classes themselves didn't change at all. The only change we did is in PrettyPrinter, so that it'd print to System.out as it goes, instead of building a giant String (used for debugging).

________________
TESTING STRATEGY

Production rules were added to the grammar while working opposite Quicksort.ic. That is, every time
a rule was added, we checked that we are making progress in parsing Quicksort.ic.

Later, after Quicksort.ic was parsed as a whole, the rest of the IC grammar was introduced to IC.cup.

Then, the file OrderOfThings.ic was created to test for additional issues and corner cases we could've thought of.

Finally the file TestBonus2Case.ic was created for the cases in bonus 2.

_______________
ERROR REPORTING

For each syntax error, we try to show some informative info:

- The line number in which the erroneous token appeared;
- The erroneous token itself;
- The whole line to give context;
- A list of expected tokens (up to 5):

  Implemented by trying to see if an action could be taken for any other possible symbol.
  For example, if trying to parse the following class member:
  int [0] arrField;
  The INTEGER(0) is an illegal symbol in that case.
  int [(*)0] arrField;
  But, by iterating through any other symbol in the current parse state, we can see that 
  in that state the only possible other symbol is RB (because the parser knows that it currently produces 'type').
  So that information is used: The action table row is scanned to see if any other symbol would be legal. If only
  a limited number of symbols are legal, we print them.
  
  Implemented in IC.cup->Parser.java, getPossibleActions().
  
- For some rare cases, an additional specialized error message:

  Currently detects some occurences of a single case (the one that was handled for PA2 bonus):
  The cases of if (cond) int x;
  
  The detection is done by stupidly inspecting the stack and the current token, and looking for cases where the
  current token is a type definition, and the closest ancestor is an IF, ELSE or WHILE statement. It'd probably miss
  out on many cases.
  
  Implemented in CourtesyErrorReporter.java.

We did not implement bonus 1. :(

___________________
KNOWN DESIGN ISSUES

1. The value of the 'value' property of a Literal object of type LiteralTypes.INTEGER 
   is of type String.

We thought it'd be better design to give an actual java Integer to the Literal AST node. But the 
range checking proved harder than it initially seemed.
We had issues with the number -2147483648 (-2^32). This number, which is a legal int value, is parsed
as two tokens: UMINUS and INTEGER_LITERAL(2147483648).
Note that this is an illegal value for an integer literal, thus parseInt() didn't work.
  
As a possible fix, we thought about changing the regex for INTEGER_LITERAL:
from [0]+|[1-9]({DIGIT})*
to   [0]+|-?[1-9]({DIGIT})*
  
But this was not a good call, as something like -5-3 would be parsed as INTEGER(-5) INTEGER(-3) 
instead of INTEGER(-5) MINUS INTEGER(3)
  
So we'd have to delay the actual parseInt() operation to a later stage of the compiler.

On the other hand, the value of a Literal object of type LiteralTypes.STRING does hold the unquoted
and unescaped instance of the string.


2. Since Library.cup and IC.cup use the same lexer, they also need to
   have the same terminal specifications.

We started off by having only a subset of the terminals in Library.cup. The problem is that 
when generating LibraryParser.java, sym.java is also generated. But that version of sym.java is ignored, and
only the version of sym.java from generating IC.cup is used.

So the two of them have to be synced.


3. Duplicated logic in Library.cup and IC.cup.

Some of the code relating to error reporting is duplicated in IC.cup and Library.cup. Since some of it
couldn't be refactored out of the .cup files (since they access protected fields of lr_parser), all of it
was duplicated.

___________
THE GRAMMAR

In producing the grammar, we tried to stay close to the syntax of the IC language.

The terminals are the same we had in PA1, with one addition (UMINUS).


Below are the productions (taken from CUP's -dump_grammar option), with some notes where due.
Please read all of the comments, as they also explain important changes (such as bonus implementation).

===== Productions =====
[0] program ::= class_list 
[2] class_list ::=                          
Syntactically, an empty program is legal.

[3] class_list ::= class_list class
This order guarantees that the classes will be parsed in top-to-bottom order.
This repeats itself in every list parsing: fields_or_methods, fields, id_list, formals,
statement_list, arg_list.

[4] class ::= CLASS CLASS_ID LCBR fields_or_methods RCBR 
[5] class ::= CLASS CLASS_ID EXTENDS CLASS_ID LCBR fields_or_methods RCBR 
[6] fields_or_methods ::= 
[7] fields_or_methods ::= fields_or_methods fields 
[8] fields_or_methods ::= fields_or_methods method 
A helper class was made to deal with those: ClassMembersHelper. It holds fields and methods.

[9] fields ::= type id_list SEMI 
A deviation from the grammar in the IC spec: this non-terminal is called 'fields' and not 'field'. That's
because it is a declaration of one-or-more fields, actually.

[10] id_list ::= ID 
[11] id_list ::= id_list COMMA ID 
[12] method ::= type ID LP formals RP LCBR statement_list RCBR 
[13] method ::= VOID ID LP formals RP LCBR statement_list RCBR 
[14] method ::= STATIC type ID LP formals RP LCBR statement_list RCBR 
[15] method ::= STATIC VOID ID LP formals RP LCBR statement_list RCBR 
A special production had to be used for VOID-returning-methods.

[16] formals ::= 
[17] formals ::= formal 
[18] formals ::= formals COMMA formal 
[19] formal ::= type ID 
[20] type ::= INT 
[21] type ::= BOOLEAN 
[22] type ::= STRING 
[23] type ::= CLASS_ID 
[24] type ::= type LB RB 
[25] statement_list ::= 
[26] statement_list ::= statement_list statement 
[27] statement ::= decl_statement
[28] statement ::= action_statement
Bonus 2: We divided the statement into two possible statement types: Those that declare
new variables, and those that don't.
Conditional branches don't allow those that do to be a single statement with no new enclosing scope.

[29] action_statement ::= location ASSIGN expression SEMI 
[30] action_statement ::= call SEMI 
[31] action_statement ::= RETURN SEMI 
[32] action_statement ::= RETURN expression SEMI 
[33] action_statement ::= IF LP expression RP action_statement 
[34] action_statement ::= IF LP expression RP action_statement ELSE action_statement 
[35] action_statement ::= WHILE LP expression RP action_statement 
[36] action_statement ::= BREAK SEMI 
[37] action_statement ::= CONTINUE SEMI 
[38] action_statement ::= LCBR statement_list RCBR 
[39] decl_statement ::= type ID SEMI 
[40] decl_statement ::= type ID ASSIGN expression SEMI 
[41] expression ::= location 
[42] expression ::= call 
[43] expression ::= THIS 
[44] expression ::= NEW CLASS_ID LP RP 
[45] expression ::= NEW type LB expression RB 
[46] expression ::= expression DOT LENGTH 
[47] expression ::= binop 
[48] expression ::= unop 
A deviation from the IC syntax in the spec: instead of the production
[expression ::= expression binop expression] where binop just stands for the operator,
our non terminal binop stands for the binary operation.
This had to be like this for the precedence declarations to be taken into account.
Same for unop.

[49] expression ::= literal 
[50] expression ::= LP expression RP 
[51] call ::= static_call 
[52] call ::= virtual_call 
[53] static_call ::= CLASS_ID DOT ID LP arg_list RP 
[54] virtual_call ::= ID LP arg_list RP 
[55] virtual_call ::= expression DOT ID LP arg_list RP 
[56] arg_list ::= 
[57] arg_list ::= expression 
[58] arg_list ::= arg_list COMMA expression 
[59] location ::= ID 
[60] location ::= expression DOT ID 
[61] location ::= expression LB expression RB 
[62] binop ::= expression PLUS expression 
[63] binop ::= expression MINUS expression 
[64] binop ::= expression MULTIPLY expression 
[65] binop ::= expression DIVIDE expression 
[66] binop ::= expression MOD expression 
[67] binop ::= expression LT expression 
[68] binop ::= expression LTE expression 
[69] binop ::= expression GT expression 
[70] binop ::= expression GTE expression 
[71] binop ::= expression EQUAL expression 
[72] binop ::= expression NEQUAL expression 
[73] binop ::= expression LAND expression 
[74] binop ::= expression LOR expression 
[75] unop ::= MINUS expression 
[76] unop ::= LNEG expression 
[77] literal ::= INTEGER 
[78] literal ::= QUOTE 
[79] literal ::= TRUE 
[80] literal ::= FALSE 
[81] literal ::= NULL